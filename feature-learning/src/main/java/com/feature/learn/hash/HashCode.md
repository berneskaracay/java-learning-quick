hashcode在java中的应用？

# HashCode

在`String`里的代码如下:

```java
public int hashCode() {
  int h = hash;
  if (h == 0 && value.length > 0) {
    char val[] = value;
    for (int i = 0; i < value.length; i++) {
      h = 31 * h + val[i];
    }
    hash = h;
  }
  return h;
}
```

为了体现输入的内容改变很小也会对其hash值产生千差万别的效果，此处使用了一个**乘数**(31)对每一个位置的字符进行相乘累加的处理方法来实现，那么为什么此处会使用31来作为乘数呢？从以下三点进行研究

## 为什么是31

#### 信息丢失

引用《Effective Java》一书中的内容

> 选择数字31是因为它是一个奇质数，如果选择一个偶数会在乘法运算中产生溢出，导致数值信息丢失，因为乘二相当于移位运算。选择质数的优势并不是特别的明显，但这是一个传统。同时，数字31有一个很好的特性，即乘法运算可以被移位和减法运算取代，来获取更好的性能：`31 * i == (i << 5) - i`，现代的 Java 虚拟机可以自动的完成这个优化。

这里牵扯到二进制的乘法运算，会产生溢出最终导致信息丢失，我们来看一个示例

![偶数](https://i.loli.net/2019/08/29/q1uH7RQISkZigeV.png)

![奇数](https://i.loli.net/2019/08/29/SHLnrvUzwi1bCma.png)



# //TODO超出范围的计算？精度的丢失？

所以这个**乘数首先不能是偶数！**

#### 性能

上面提到`31 * i == (i << 5) - i`,也就是说JVM在处理这一行的时候会把乘法准换成移位操作，

`<<` 代表二进制数的左移操作即**低位补0，高位丢弃**，假设这里`i=13`，其操作如下:

```
13		        0000 0000 0000 0000 0000 0000 0000 1101
13 << 5 		0000 0000 0000 0000 0000 0001 1010 0000
13 << 5 - 13	0000 0000 0000 0000 0000 0000 0000 1101
-----------------------------------------------------------
403				0000 0000 0000 0000 0000 0001 1001 0011
```

对于`13 * 31` 位运算过程如下(类似十进制的乘法):

```
13				0000 0000 0000 0000 0000 0000 0000 1101
31				0000 0000 0000 0000 0000 0000 0001 1111
-----------------------------------------------------------
					0000 0000 0000 0000 0000 0000 0000 1101
			   0000 0000 0000 0000 0000 0000 0000 1101
        0000 0000 0000 0000 0000 0000 0000 1101
       0000 0000 0000 0000 0000 0000 0000 1101 
      0000 0000 0000 0000 0000 0000 0000 1101 
-----------------------------------------------------------
403		  0000| 0000 0000 0000 0000 0000 0001 1001 0011    
```

通过简单的代码做耗时比较:

```java
    public static void testBitOpera() {
        int val = 28;
        long s = System.nanoTime();
        for (int i = 0; i < 100000000; i++) {
            int i1 = 29 * 31;
        }
        System.out.println(System.nanoTime() - s); // 1937665
        s = System.nanoTime();
        for (int i = 0; i < 100000000; i++) {
            int i1 = (29 << 5) - 29;
        }
        System.out.println(System.nanoTime() - s); // 951104
    }
```

也能看出来位运算比直接的运算快(JVM会对每一个代码自动优化，我们程序员可以不用去管)

[关于Java对于乘除法的优化](http://fanyilun.me/2015/04/21/关于Java对于乘除法的优化/)

**`31 * i`是可以被JVM优化为` (i << 5) - i`的**

#### Hash范围大小

代码里hashcode的返回值为`int`,对应的quzhi范围是:`2^31~2^31-1,就`31 * 0 + val[0]`这个算法，可以简单推出当长度为n的时候的一个公式为:

`s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]`

我们可以拿几个数值来看一下，以下只计算公式中次数最高的那一项`31^(n-1)`，当乘数是2的时候，假设n=6,结果` 2^5`为32，比较小所以这里可以断定，当字符串长度不是很长时，用质数2做为乘子算出的哈希值，数值不会很大。也就是说，哈希值会分布在一个较小的数值区间内，分布性不佳，最终可能会导致冲突率上升。

如果使用101呢，`101^5`是`10,510,100,501`远远超出`2^31-1`的范围，上面说到溢出就会导致信息丢失，所以乘数太大也不是一个好的选择；

再看看31，`31^5`是`28629151`相比较`32`和`10,510,100,501`来说，非常不错，但是又有一个问题，31可以的话，那37，41，43为什么不行呢？接着往下看！

**Hash取值的范围要是尽可能的广**



#### Hash冲突占比

hash里面最重要的另一个非冲突莫属了，通过上面的算法`h = 31 * h + val[i];`可以得出，对应字符串的每一位改动都会对hashcode造成千差万别的变化，但是始终会出现不同字符串产生同一hashcode的情况，比如：

```java
System.out.println(Objects.hashCode("La's")); // 2358657
System.out.println(Objects.hashCode("MB's")); // 2358657
```

接着上一节，把101以内的素数当做乘数来统计一下冲突率,结果如下

![冲突率](https://i.loli.net/2019/08/31/Kl2nSphwEfajZ9g.png)

可以看到31、37、29、41下的冲突个数和冲突率都相差不大，这也验证了单从冲突率来看这几个数也都是可以作为乘数的。



#### Hash分布情况 

直接拿图了如下， 

![](https://i.loli.net/2019/08/31/NVPZS3FoMmYdu7s.png)



![](https://i.loli.net/2019/08/31/reAPbYfCFLs1Ma8.png)

![](https://i.loli.net/2019/08/31/ZyBRhkTGOebCrsW.png)

![](https://i.loli.net/2019/08/31/YuwcDACdZ7PNnE9.png)

![](https://i.loli.net/2019/08/31/HCYBcFIz9onk2rR.png)

hash分布情况31也算是比较好



综上所述，31胜出！！！

## HashMap中的Hash

HashMap中对hashcode又做了一次加工，如下:

```java
static final int hash(Object key) {
  int h;
  return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

主要就是这里`(h = key.hashCode()) ^ (h >>> 16)`将key的hash值无符号右移16位再与自己做异或位操作，举个例子：

```
"vector".hashCode()					1100 1111 0001 1001 1110 0001 0100 0011
"vector".hashCode() >>> 16  0000 0000 0000 0000 1100 1111 0001 1001
^														1100 1111 0001 1001 0010 1110 1010 1010
```

我们先看一看拿到这个异或结果是用来做什么的，在后面`putVal`方法中有这一句代码

`(p = tab[i = ])`，而`tab`是一个声明的数组`Node<K,V>[] tab`,也就是说`(n - 1) & hash`是为了确定下标，其实就是`hash % n`,这里直接写做位运算提高计算效率，举几个例子：

假设数组的长度为16，(16-1=15)的二进制为`0000 0000 0000 0000 0000 0000 1111` 分别于下面几个hash做`&`操作

```
1111 & 0000 0000 0001 0101 0100 1010 0100 1000 结果：1000 = 8
1111 & 0000 0000 0001 0100 0101 1010 0100 1001 结果：1001 = 9
1111 & 0000 0000 0001 0101 0101 1011 0100 1010 结果： 1010 = 10
1111 & 0000 0000 0001 0110 0100 1110 0110 1100 结果： 1100 = 12
```

这里可以简单的看出一个规律，如果`(n - 1)`对应的二进制是`*1111*`的时候，最终的取值还是由key的hashcode自己来决定，我的理解就是**让每一个key对应的下标都是公平公正并且与自己息息相关！**

这里也就引出了为什么HashMap要求容量为2的幂次方，

> ```
> The default initial capacity - MUST be a power of two.
> ```

因为`2^n-1` 对应的二进制就是`*1111`。

但是这里又会出现另一个情况，如果一批key对应的hashcode如下

```
0000 0000 0001 0101 0100 1010 0100 1000
0000 0000 0001 0100 0100 1010 0100 1000
0000 0000 0001 1101 0100 1010 0100 1000
0000 0000 0001 0111 0100 1010 0100 1000
```

这四个与数组长度做`&`后的记过均是8，也就产生了“碰撞”，也就是说这四个key都会放在下标为8的位置上，接着会形成链表或红黑树结构，那这显然不是最好的结果，因为这种情况非常常见，典型的高位改变低位不便的情况，所以为此，源码的作者在原本hashcode的基础上又加上了一层“扰动函数”，即

`(h = key.hashCode()) ^ (h >>> 16)` 高明之处在于将hashcode的**前半高位**跟**后半低位**做`^`操作，这样就会把一个key的信息全部保留在低位，再与数组长度做`&`操作的时候就会显得更加公平，因为高低位都`参与`了，都奉献了自己的价值，这样就再一次提升了公平性！此时我们再走下上面的结果：

```
0000 0000 0001 0101 0100 1010 0100 1000
0000 0000 0001 0100 0100 1010 0100 1000
0000 0000 0001 1101 0100 1010 0100 1000
0000 0000 0001 0111 0100 1010 0100 1000
```

将它们右移16位之后与自己做`^`操作，结果如下：

```
0000 0000 0001 0101 0100 1010 0101 1101
0000 0000 0001 0100 0100 1010 0101 1100
0000 0000 0001 0101 0100 1010 0101 0101
0000 0000 0001 0111 0100 1010 0101 1111
```

然后再与

再与数组长度做`&`操作，结果如下:

```
0000 0000 0000 0000 0000 0000 0000 1101  13
0000 0000 0000 0000 0000 0000 0000 1100  12 
0000 0000 0000 0000 0000 0000 0000 0101  5
0000 0000 0000 0000 0000 0000 0000 1111  16
```

太好了，这四个key会被放在不同的位置，没有出现冲突！

总结：数组容量大小为2的幂次方，保证数组下标计算时，减少自己的“干扰”；Hashmap中hashcode在原来的基础上加了一层**扰动函数**，保留了高低位的信息，后面再计算数组下标的时候让每一位的数据都参与了计算，保证最后的下标是公平公正！



#### 脑筋急转弯

如何判断一个数是不是2的幂次方？



## Hash一致性



参考：

https://stackoverflow.com/questions/32042346/why-does-this-multiplication-integer-overflow-result-in-zero

https://blog.csdn.net/qq_38182963/article/details/78940047

https://www.zhihu.com/question/23172611