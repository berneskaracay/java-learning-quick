    
# Java中高位转低位溢出的计算过程

```java
System.out.println((byte) 129);
System.out.println((byte) -129);
System.out.println("~b2: " + ~10);
```
结果是：
```
-127
127
~b2: -11
```

**计算机中是以补码进行计算**

正数的反码补码都是原码，如：
10
原码: `1010`
反码: `1010`
补码：`1010`

负数 -10
原码 `10000000 00000000 00000000 00001010`
反码(符号位不变，其余位取反) `01111111 11111111 11111111 11110101`
补码(反码+1)： `01111111 11111111 11111111 11110110`

### (byte) 129
对于129，二进制为
`00000000 00000000 00000000 10000001`
其补码：`00000000 00000000 00000000 10000001`
由于byte只占1字节即8位，所以，上面截取8位置后如下：`10000001`
此时最高位为1即负数，该二进制减1即是反码
反码：`10000000`
原码：`11111111`
即-127，所以`(byte)129`的结果就是`-127`

### (byte) -129
-129 二进制为
`10000000 00000000 00000000 10000001`
对应的补码为(反码+1)
`11111111 11111111 11111111 01111111`
截取8为后为：`01111111`
为正数，其原码反码补码均为`01111111`即127
所以`(byte)-129`的结果就是`127`

### ~10
10的二进制为
`00000000 00000000 00000000 00001010`
补码是本身，取反之后为
`11111111 11111111 11111111 11110101`
此时最高位为1，负数，即是负数的补码
该反码(补码-1)
`11111111 11111111 11111111 11110100`
对应的原码：
`10000000 00000000 00000000 00001011` 即-11
所以`~b2`的结果是`-11`

### 总结
- 计算机中是以补码进行计算，原码进行显示
- 正数的反码补码都是其本身
- 负数的反码是原码符号位不变其他取反，补码是反码+1