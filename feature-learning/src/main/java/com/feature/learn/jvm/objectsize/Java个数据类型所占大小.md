# 基本数据类型各自所占大小



### byte与bit

bit： 位，比特。 信息的最小单位，二进制数中的一个位数(二进制位)，其值为“0”或“1”；

byte: 字节。计算机文件大小的基本计算单位;



- 原码：正数本身，负数，正数对应的二进制最高位为1(负)；

- 反码：正数本身，负数，符号位不变，其余各位取反；

- 补码：正数本身，负数：反码+1
- 0的反码、补码都为零

**注意: 计算机处理是以补码形式，我们最终看到的是原码形式**

例如：

```java
System.out.println((byte)233); // -23
System.out.println((byte)-233); // 23
System.out.println("~b2: " + ~10); // -11
```



### 列表

| 类型    | 存储需求 | bit 数 | 取值范围               | 备注                                                         |
| ------- | -------- | ------ | ---------------------- | ------------------------------------------------------------ |
| byte    | 1字节    | 1 * 8  | -128 ~ 127             | 字节类型。即 (-2)的7次方 ~ (2的7次方) - 1                    |
| short   | 2字节    | 2 * 8  | -32768 ~ 32767         | 短整型。即 (-2)的15次方 ~ (2的15次方) - 1                    |
| int     | 4字节    | 4 * 8  | -2147483648~2147483647 | 整型。即 (-2)的31次方 ~ (2的31次方) - 1                      |
| long    | 8字节    | 8 * 8  |                        | 长整形。即 (-2)的63次方 ~ (2的63次方) - 1                    |
| float   | 4字节    | 4 * 8  |                        | 浮点型(单精度)。float 类型的数值有一个后缀 F（例如：3.14F）<br />1bit（符号位） 8bits（指数位） 23bits（尾数位） |
| double  | 8字节    | 8 * 8  |                        | 浮点型(双精度)。没有后缀F的浮点数值(如3.14)默认为double类型<br />1bit（符号位） 11bits（指数位） 52bits（尾数位） |
| char    | 2字节    | 2 * 8  |                        | 字节型。Java中，只要是字符，不管是数字还是英文还是汉字，都占两个字节。 |
| boolean | 1字节    | 1 * 8  | true、false            | 布尔型。                                                     |

注意：

- **对于数组32，默认为int型，32B为byte类型，32S为short类型，32L为long型**

- 基本数据类型自动转换(低转高，高转低会丢失精度)
    - byte -> short
    - char -> int -> long
    - float -> double
    - int -> float
    - long -> double

[高转低强转的方法](https://www.cnblogs.com/1020182600HENG/p/6765466.html)



基本类型字节占用
https://blog.csdn.net/litong09282039/article/details/46348265
https://www.jianshu.com/p/fd560bc39adb
https://blog.csdn.net/qq_27093465/article/details/52262651

[字节、字、bit、byte的关系](https://blog.csdn.net/wanlixingzhe/article/details/7107923)



### Java中对象占用内存大小

#### 对象的组成

##### 对象头(Header)

> “用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为"Mark Word”
>

32位系统占用8bytes,64位占用16bytes

数组对象头则是24byte，比普通对象多了空间存储数组长度

###### 实例数据(Instance Data)

> “对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来”
>

- 参照上面列表占用大小;
- 引用类型(reference)在32位系统上每个占用4bytes, 在64位系统上每个占用8bytes;

###### 对其补充(Padding)

>“第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或者2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。”

HotSpot的对齐方式为8字节对齐：

```
(Header + Instance Data + Paddding) % 8 = 0 并且 0 <= padding < 8
```



##### 指针压缩

- 对象占用的内存大小收到VM参数**UseCompressedOops**的影响。

开启（-XX:+UseCompressedOops）对象头大小为12bytes（64位机器）。

- 对reference类型的影响

64位机器上reference类型占用8个字节，开启指针压缩后占用4个字节。

- 数组影响

64位机器为24bytes，压缩后16bytes



#### 复合对象

综合上面的运算规则

##### 对象本身的大小

直接计算当前对象占用空间大小，包括当前类及超类的**基本类型实例字段大小**、**引用类型实例字段引用大小**、**实例基本类型数组总占用空间**、**实例引用类型数组引用本身占用空间大小**; 但是不包括超类继承下来的和当前类声明的实例引用字段的对象本身的大小、实例引用数组引用的对象本身的大小。 

##### 当前对象占用的空间总大小

递归计算当前对象占用空间总大小，包括当前类和超类的实例字段大小以及实例字段引用对象大小。

递归计算复合对象占用的内存的时候需要注意的是：对齐填充是以每个对象为单位进行的



内存大小计算
https://www.cnblogs.com/zhanjindong/p/3757767.html


