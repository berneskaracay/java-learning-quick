### 参考
https://zhuanlan.zhihu.com/p/41672523

https://blog.csdn.net/xyang81/article/details/7292380







### 类加载的过程
加载(Loading)->连接(Linking)->初始化(Initialization)->使用(Using)->卸载(Unloading)
其中连接又分为 验证(Verification)->准备(Preparation)->解析(Resoluation)





#### 加载

通过一个类的全限定名来获取(从zip包、网络、运行时计算生成、其他文件生成、数据库中读取等等)定义此类的二进制字节流；将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法去这个类的各种数据的访问入口。

#### 链接

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序

##### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。



##### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

这时候内存分配的仅包括类变量(被static修饰的变量)，不包括示例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，如

```java
public static int value = 123;
```

此时变量`value`准备阶段后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的`putstatic`指令是程序被编译后，存放于类构造器`＜clinit＞()`方法之中，所以把value赋值为123的动作将在初始化阶段才会执行!

但是如果存在`ConstantValue`属性，则会被初始化，如下:

```java
public static final int value = 123;
```

编译时`Javac`会为value生成`ConstantValue`属性，则会把value赋值为123



##### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

- 符号引用(Symbolic References)

- 直接引用(Direct References)



#### 初始化

类初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码（或者说是字节码）

简单的理解就是，在之前的准备阶段，一些变量已经赋过一次**系统要求**的初始值，而在此(初始化)阶段则是通过程序制定的主观计划初始化类变量和其他资源！

### 类与类加载器

判断两个类是否相同的前提必须得是同一个加载器进行加载的，否则下面情况始终是不相等的

```java
com.feature.learn.classloader.ClassLoaderTest$1@53d8d10a
sun.misc.Launcher$AppClassLoader@18b4aac2
```

> 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。



从Java虚拟机的角度来讲，只存在两种不同的类加载器，

- 启动类加载器(Bootstrap ClassLoader)，使用C++语言实现，是虚拟机自身的一部分；
- 所有其他类加载器，这些类加载器有Java语言实现，独立于虚拟机外部，并且全都继承自抽象类`java.lang.ClassLoader`

从Java开发人员的角度来看，绝大部分Java程序会使用到一下3中系统提供的类加载器：

- 启动(引导)类加载器(Bootstrap ClassLoader): 负责存放在**`<JAVA_HOME>\lib`**目录中的或者着被**`-Xbootclasspath`**参数所指定的路径中的，并且是**虚拟机识别**的类库加载到虚拟机内存中。无法被Java程序直接引用！用户在编写自定义了加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

- 扩展类加载器(Extension ClassLoader): 由`sun.misc.Launcher$ExtClassLoader`实现，负责加载`<JAVA_HOME>\lib\ext`目录中的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序加载器(Application ClassLoader)： 由`sun.misc.Launcher$App-ClassLoader`实现，由于这个类加载器是ClassLoader中的`getSystemClassLoader()`方法的返回值，所以一般称他为系统类加载器，负责加载用户类路径(ClassPath)上所制定的类库，开发者可以直接使用这个类加载器，如果程序中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。



#### 双亲委派模型

“双亲委派”理解起来可能会误导，英文为:`Parents Delegation Model`,译为"父辈代理"会更加妥当！

![类加载器双亲委派模型](http://cdn.wangxc.club/image/20191008/gxd0PfVxhToM.png?imageslim)

此模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，这里的父子关系一般不会已继承的关系实现，而是使用组合的关系来复用父加载器的代码。

其过程为：

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器去完成，每一个 层次的类加载器都是如此，因此所有的加载请求最终都应当传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载。

比如说`java.lang.String`，如论哪一个加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，所以在程序的哥类加载器环境中都是同一个类，如果用户自己编写了这个类，可以发现这个类可以正常编译，但是无法被加载

```java
package java.lang;

public class System {
    private int age;
    public int getAge() {
        return 1;
    }
    public static void main(String[] args) {
        System str = new System();
    }
}
```

结果

![无法加载](http://cdn.wangxc.club/image/20191008/fHIstVvApWa7.png?imageslim)

**注意: 这里只限于HotSpot虚拟机，像MRP、Maxine等虚拟机，整个虚拟机本身都是由Java编写的，自然Bootstrap ClassLoader也是由Java语言而不是C++实现的**



### 破坏双亲委派模型

