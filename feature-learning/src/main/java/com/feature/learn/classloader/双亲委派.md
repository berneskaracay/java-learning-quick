### 参考
https://zhuanlan.zhihu.com/p/41672523

https://blog.csdn.net/xyang81/article/details/7292380





“双亲委派”理解起来可能会误导，英文为:`parents delegate`,译为"父辈代理"会更加妥当！

类的一生
加载(Loading)->连接(Linking)->初始化(Initialization)->使用(Using)->卸载(Unloading)
其中连接又分为 验证(Verification)->准备(Preparation)->解析(Resoluation)



判断两个类是否相同的前提必须得是同一个加载器进行加载的，否则下面情况始终是不相等的

```java
com.feature.learn.classloader.ClassLoaderTest$1@53d8d10a
sun.misc.Launcher$AppClassLoader@18b4aac2
```

> 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。这句话可以表达得更通俗一些：比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。



#### 加载

通过一个类的全限定名来获取(从zip包、网络、运行时计算生成、其他文件生成、数据库中读取等等)定义此类的二进制字节流；将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构；在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法去这个类的各种数据的访问入口。

#### 链接

加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序

##### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

- 文件格式验证
- 元数据验证
- 字节码验证
- 符号引用验证

对于虚拟机的类加载机制来说，验证阶段是一个非常重要的、但不是一定必要（因为对程序运行期没有影响）的阶段。如果所运行的全部代码（包括自己编写的及第三方包中的代码）都已经被反复使用和验证过，那么在实施阶段就可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。



##### 准备

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。

这时候内存分配的仅包括类变量(被static修饰的变量)，不包括示例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中，如

```java
public static int value = 123;
```

此时变量`value`准备阶段后的初始值为0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的`putstatic`指令是程序被编译后，存放于类构造器`＜clinit＞()`方法之中，所以把value赋值为123的动作将在初始化阶段才会执行!

但是如果存在ConstantValue属性，则会被初始化，如下:

```java
public static final int value = 123;
```

编译时Javac会为value生成ConstantValue属性，则会把value赋值为123



##### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

- 符号引用(Symbolic References)

- 直接引用(Direct References)